// AUTO-GENERATED FILE.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;
import ballerina/log;
import ballerina/time;

// import ballerina/time;

listener http:Listener ep0 = new (9090, config = {host: "localhost"});

const SECONDS_IN_A_YEAR = 31536000; // Approximate number of seconds in a year

// Service-level CORS configuration
@http:ServiceConfig {
    cors: {
        allowOrigins: ["*"], // Allow all origins or specify your allowed origins
        allowCredentials: false,
        allowHeaders: ["Content-Type", "Authorization"],
        exposeHeaders: ["X-Custom-Header"],
        maxAge: 3600
    }
}

service / on ep0 {
    resource function options programme() returns http:Response {
        // Create a response object with status code 204 and appropriate CORS headers
        http:Response response = new;

        response.statusCode = 204; // No Content
        response.reasonPhrase = "No Content";

        // Add CORS headers using appropriate methods
        response.addHeader("Access-Control-Allow-Origin", "*"); // or specify allowed origins
        response.addHeader("Access-Control-Allow-Methods", "GET, POST, PUT, OPTIONS");
        response.addHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
        response.addHeader("Access-Control-Max-Age", "3600");

        return response;
    }



    // # Retrieve a specific programme by programme code
    resource function get programmes/[string programmeCode]() returns Programme|http:NotFound {
        Programme? programme = ProgrammeTable[programmeCode];
        if (programme is ()) {
            return {
                body: {
                    errmsg: string `Invalid programme code: ${programmeCode}`
                }
            };
        }
        return programme;
    }

    // # Retrieve all programmes that belong to the same faculty
    resource function get programmes/faculty/[string facultyName]() returns Programme[]|http:NotFound {
        Programme[] foundProgrammes = [];

        foreach var programme in ProgrammeTable {
            // Use member access to safely check if faculty is present and matches
            if (programme.faculty is string && programme.faculty == facultyName) {
                foundProgrammes.push(programme);
            }
        }

        if (foundProgrammes.length() == 0) {
            return {
                body: {
                    errmsg: string `No programmes found for the faculty: ${facultyName}`
                }
            };
        }

        return foundProgrammes;
    }

    // # Retrieve all programmes that are due for review
    resource function get programmes/review/due() returns Programme[]|http:NotFound {
        // Get the current UTC time
        time:Utc currentUtc = time:utcNow();

        // Create a list to store programmes due for review
        Programme[] dueForReview = [];

        // Define the number of seconds in 5 years (including leap years)
        int secondsInFiveYearsInt = 5 * 365 * 24 * 60 * 60 + 2 * 24 * 60 * 60; // Approximation for leap years

        // Cast the int seconds to time:Seconds
        time:Seconds secondsInFiveYears = <time:Seconds>secondsInFiveYearsInt;

        // Iterate through the ProgrammeTable to check each programme
        foreach Programme programme in ProgrammeTable {
            // Ensure the registrationDate is present and valid
            if (programme.registrationDate is string) {
                // Convert the registrationDate string to time:Utc
                time:Utc|time:Error registrationUtc = time:utcFromString(programme.registrationDate);

                // Handle the case where conversion fails
                if (registrationUtc is time:Error) {
                    // Log the error and skip this entry
                    log:printError("Error converting registration date to UTC", registrationUtc);
                    continue; // Skip this entry and move to the next one
                }

                // Proceed with valid registrationUtc
                // Calculate the time when the programme would be due for review
                time:Utc reviewDueUtc = time:utcAddSeconds(registrationUtc, secondsInFiveYears);

                // Check if the current UTC time is past the review due time
                if (currentUtc >= reviewDueUtc) {
                    dueForReview.push(programme);
                }
            }
        }

        // Check if any programmes are due for review
        if (dueForReview.length() == 0) {
            return {
                body: {
                    errmsg: "No programmes are due for review."
                }
            };
        }

        return dueForReview;
    }

    // # Add a new programme
    resource function post programmes(@http:Payload Programme[] programmes) returns Programme[]|error {
        string[] conflictingProgrammeCodes = from Programme programme in programmes
            where ProgrammeTable.hasKey(programme.programmeCode)
            select programme.programmeCode;

        if (conflictingProgrammeCodes.length() > 0) {
            // Manually concatenate the conflicting programme codes
            string errorMsg = "CONFLICTING PROGRAMME CODES: ";
            foreach string code in conflictingProgrammeCodes {
                errorMsg += code + " ";
            }
            // Trim the trailing space
            errorMsg = errorMsg.trim();

            return error(errorMsg);
        } else {
            foreach Programme programme in programmes {
                ProgrammeTable.add(programme);
            }
            return programmes;
        }
    }

    // # Update an existing programme's information
    resource function put programmes/[string programmeCode](@http:Payload Programme payload) returns Programme|InvalidProgrammeCodeError {
        Programme? existingProgramme = ProgrammeTable[programmeCode];

        if (existingProgramme is ()) {
            return {
                body: {
                    errmsg: "Invalid programme code: " + programmeCode
                }
            };
        }

        Programme updatedProgramme = {
            programmeCode: existingProgramme.programmeCode, // Use the existing programmeCode
            nqfLevel: payload.nqfLevel,
            faculty: payload.faculty,
            department: payload.department,
            title: payload.title,
            registrationDate: payload.registrationDate,
            courses: payload.courses
        };

        _ = ProgrammeTable.remove(programmeCode);
        ProgrammeTable.add(updatedProgramme);

        return updatedProgramme;
    }

}
